<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Калькулятор раскроя металла — с цветами по длине</title>
<style>
  * { box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  html, body { margin: 0; padding: 0; background: #f5f5f5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  body {
    max-width: 1200px;
    margin: 0 auto;
    padding: 16px;
    font-size: 18px;
    overflow-x: hidden;
  }
  .container { display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-start; }

  .input-section, .result-section {
    background: #fff;
    padding: 18px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
  }
  .input-section { flex: 1; min-width: 300px; max-width: 420px; }
  .result-section { flex: 2; min-width: 320px; }

  h1,h2,h3 { color: #2c3e50; margin: 0 0 12px 0; }
  .form-group { margin-bottom: 12px; }
  label { display:block; margin-bottom:6px; font-weight:600; }
  input[type="number"], select, button {
    width: 100%;
    padding: 10px 12px;
    border-radius: 6px;
    border: 1px solid #ddd;
    font-size: 16px;
  }
  button { background:#3498db; color:#fff; border: none; font-weight:700; cursor:pointer; }
  button:hover { background:#2980b9; }
  .cuts-list { margin-top: 10px; }
  .cut-item { display:flex; justify-content:space-between; align-items:center; gap:8px; padding:8px; background:#f9f9f9; border-radius:6px; margin-bottom:8px; }
  .delete-btn { background:#e74c3c; color:#fff; padding:6px 8px; border-radius:6px; border:none; cursor:pointer; }

  .result-item { margin-bottom:14px; padding:14px; background:#fafafa; border-radius:8px; position:relative; overflow:hidden; border:1px solid rgba(0,0,0,0.04); }
  .result-item .stock-header { margin:0 0 6px 0; font-size:18px; }
  .result-item.completed { background:#e8f5e9; }
  .result-item.completed .cut-piece { background:#8bc34a !important; color: #fff; }

  .cut-pieces { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; align-items:center; }
  .cut-piece {
    background:#3498db;
    color:#fff;
    padding:8px 12px;
    border-radius:6px;
    min-width:80px;
    max-width:100%;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    flex:0 1 auto;
    font-size:14px;
    border:1px solid rgba(0,0,0,0.06);
  }
  /* при выполнении конкретного куска — делаем override на зелёный */
  .cut-piece.done { background:#8bc34a !important; color:#fff !important; }

  .cut-piece.waste { background:#e74c3c; }

  .total-info { margin-top:16px; padding:12px; background:#2c3e50; color:white; border-radius:8px; }

  .completed-checkbox { position:absolute; right:12px; top:12px; transform:scale(1.4); }
  .completed-label { position:absolute; right:52px; top:14px; color:#7f8c8d; font-size:13px; }

  .progress-wrap { margin-top:8px; }
  .progress-bar { height:10px; background:#ecf0f1; border-radius:999px; overflow:hidden; }
  .progress { height:100%; background:#2ecc71; width:0%; transition:width .4s ease; }

  .action-buttons { display:flex; gap:10px; margin-top:12px; }
  .action-buttons button { flex:1; padding:10px; font-weight:700; }

  /* legend */
  .legend { display:flex; flex-wrap:wrap; gap:8px; margin-top:12px; align-items:center; }
  .legend-item { display:flex; gap:8px; align-items:center; font-size:13px; color:#333; background:#fff; padding:6px 8px; border-radius:6px; border:1px solid rgba(0,0,0,0.04); }
  .legend-swatch { width:18px; height:14px; border-radius:3px; border:1px solid rgba(0,0,0,0.08); display:inline-block; }

  @media (max-width: 880px) {
    body { padding:12px; }
    .container { flex-direction: column; }
    .input-section, .result-section { max-width: none; width: 100%; }
    .cut-piece { min-width: 100px; font-size:15px; }
  }
  @media (max-width: 420px) {
    body { font-size: 16px; }
    .cut-piece { min-width: 90px; padding:10px 12px; font-size:16px; }
    input[type="number"], select, button { font-size:16px; padding:10px; }
  }

  .warn { margin-top:10px; padding:8px; background:#fff3cd; border:1px solid #ffeeba; color:#856404; border-radius:6px; }
</style>
</head>
<body>
  <h1>Калькулятор раскроя металла</h1>

  <div class="container">
    <div class="input-section">
      <h2>Параметры раскроя</h2>

      <div class="form-group">
        <label for="stock-length">Длина заготовки (мм):</label>
        <input id="stock-length" type="number" value="5800" min="1" data-numeric type="tel" inputmode="numeric" pattern="\d*" autocomplete="off">
      </div>

      <div class="form-group">
        <label for="algorithm">Алгоритм:</label>
        <select id="algorithm">
          <option value="greedy">Жадный</option>
          <option value="optimal">Оптимизированный (быстрый)</option>
        </select>
      </div>

      <div class="form-group">
        <label for="min-waste">Мин. допустимый остаток (мм) — остаток не может быть меньше этого значения (оставьте пустым или 0 для без ограничений):</label>
        <input id="min-waste"  min="0" placeholder="Например: 250" data-numeric type="tel" inputmode="numeric" pattern="\d*" autocomplete="off">
      </div>

      <h3>Добавить отрезки</h3>
      <div class="form-group">
        <label for="cut-length">Длина отрезка (мм):</label>
        <input id="cut-length"  min="1" data-numeric type="tel" inputmode="numeric" pattern="\d*" autocomplete="off">
      </div>

      <div class="form-group">
        <label for="cut-quantity">Количество:</label>
        <input id="cut-quantity"  min="1" value="1" data-numeric type="tel" inputmode="numeric" pattern="\d*" autocomplete="off">
      </div>

      <button id="add-cut">Добавить отрезки</button>

      <div class="cuts-list">
        <h3>Список отрезков</h3>
        <div id="cuts-container"></div>
      </div>

      <button id="calculate" style="margin-top:14px;">Рассчитать раскрой</button>

      <div class="action-buttons">
        <button id="mark-all-done" style="background:#2ecc71">Отметить все выполнено</button>
        <button id="reset-all" style="background:#e74c3c">Сбросить все отметки</button>
      </div>

      <div id="warning-box" style="display:none" class="warn"></div>
    </div>

    <div class="result-section">
      <h2>Результаты раскроя</h2>

      <div id="progress-info" style="margin-bottom:6px"></div>
      <div class="progress-wrap">
        <div class="progress-bar"><div id="progress-bar" class="progress"></div></div>
      </div>

      <div id="results-container" style="margin-top:12px"></div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  // ---------- state ----------
  let cuts = JSON.parse(localStorage.getItem('cuts')) || [];
  let completedStocks = JSON.parse(localStorage.getItem('completedStocks')) || [];
  const stockInput = document.getElementById('stock-length');
  const algoSelect = document.getElementById('algorithm');
  const minWasteInput = document.getElementById('min-waste');
  const warningBox = document.getElementById('warning-box');

  stockInput.value = parseInt(localStorage.getItem('stockLength')) || 5800;
  algoSelect.value = localStorage.getItem('algorithm') || 'greedy';
  const savedMin = localStorage.getItem('minWaste');
  if (savedMin !== null) minWasteInput.value = savedMin;

  function saveState() {
    localStorage.setItem('cuts', JSON.stringify(cuts));
    localStorage.setItem('completedStocks', JSON.stringify(completedStocks));
    localStorage.setItem('stockLength', parseInt(stockInput.value));
    localStorage.setItem('algorithm', algoSelect.value);
    localStorage.setItem('minWaste', minWasteInput.value || '');
  }

// Функция возвращает фон и цвет текста для конкретного размера
function colorForLength(len, min = 350, max = 2200, step = 50) {
    const saturation = 65; // насыщенность %
    const baseLightness = 50; // базовая светлота %
    const lightnessDelta = 6; // чередуем светлоту для соседних размеров

    const idx = Math.round((len - min) / step);
    const N = Math.round((max - min) / step) + 1;

    const offset = 20; // смещение оттенка для более приятного старта
    const hue = (offset + (idx * 360 / N)) % 360;
    const lightness = baseLightness + ((idx % 2 === 0) ? lightnessDelta : -lightnessDelta);

    const bg = `hsl(${Math.round(hue)} ${saturation}% ${Math.round(lightness)}%)`;

    // Простая эвристика для текста
    const text = (lightness < 55) ? '#ffffff' : '#222222';

    return { bg, text };
}


  function updateCutsList() {
    const container = document.getElementById('cuts-container');
    container.innerHTML = '';
    const grouped = {};
    cuts.forEach(c => grouped[c] = (grouped[c]||0)+1);
    const entries = Object.entries(grouped).sort((a,b)=>parseInt(b[0])-parseInt(a[0]));
    entries.forEach(([len, count])=>{
      const div = document.createElement('div');
      div.className = 'cut-item';
      div.innerHTML = `<span>${len} мм: ${count} шт.</span><button class="delete-btn" data-l="${len}">Удалить</button>`;
      container.appendChild(div);
    });
    container.querySelectorAll('.delete-btn').forEach(btn=>{
      btn.onclick = ()=>{
        const len = parseInt(btn.dataset.l,10);
        const idx = cuts.indexOf(len);
        if (idx !== -1) { cuts.splice(idx,1); updateCutsList(); saveState(); }
      };
    });
  }

  // ---------------- color helpers ----------------
  function hashInt(x) {
    let n = (x >>> 0);
    n = (n ^ 61) ^ (n >>> 16);
    n = n + (n << 3);
    n = n ^ (n >>> 4);
    n = (n * 0x27d4eb2d) >>> 0;
    n = n ^ (n >>> 15);
    return n >>> 0;
  }
  function hueFromLen(len) {
    return hashInt(len) % 360;
  }
  function getColorForLength(len, opts = {}) {
    const s = (opts.saturation !== undefined) ? opts.saturation : 65;
    const l = (opts.lightness !== undefined) ? opts.lightness : 50;
    const h = hueFromLen(len);
    // modern HSL with spaces is supported in modern browsers; fallback comment included
    return `hsl(${h} ${s}% ${l}%)`;
    // return `hsl(${h}, ${s}%, ${l}%)`; // fallback older syntax
  }

  // group sizes if too many unique types
  function maybeGroupSizes(sizes, maxDistinct = 18) {
    if (sizes.length <= maxDistinct) return sizes.map(v => ({ label: String(v), min: v, max: v, sample: v }));
    const min = Math.min(...sizes), max = Math.max(...sizes);
    const buckets = [];
    for (let i=0;i<maxDistinct;i++) buckets.push([]);
    const range = max - min + 1;
    sizes.forEach(v => {
      const idx = Math.floor(((v - min) / range) * maxDistinct);
      buckets[Math.min(idx, maxDistinct-1)].push(v);
    });
    const groups = buckets.filter(b=>b.length).map(b => {
      const mn = Math.min(...b), mx = Math.max(...b);
      const label = mn === mx ? `${mn}` : `${mn}–${mx}`;
      return { label, min: mn, max: mx, sample: b[Math.floor(b.length/2)] };
    });
    return groups;
  }

  function renderLegendForResults(containerSelector, results) {
    // collect counts
    const counts = {};
    results.forEach(stock => stock.pieces.forEach(len => counts[len] = (counts[len]||0)+1));
    const unique = Object.keys(counts).map(x=>parseInt(x,10)).sort((a,b)=>b-a);
    if (unique.length === 0) {
      // remove old legend if present
      const c = document.querySelector(containerSelector);
      if (!c) return;
      const old = c.querySelector('.legend');
      if (old) old.remove();
      return;
    }
    const groups = maybeGroupSizes(unique, 18);
    const container = document.querySelector(containerSelector);
    if (!container) return;
    const old = container.querySelector('.legend');
    if (old) old.remove();

    const legend = document.createElement('div');
    legend.className = 'legend';
    groups.forEach(g => {
      const sample = (g.sample !== undefined) ? g.sample : Math.round((g.min+g.max)/2);
      const swatchColor = getColorForLength(sample);
      const labelText = (g.min === g.max) ? `${g.min} мм` : `${g.label} мм`;
      let totalCount = 0;
      if (g.min === g.max) totalCount = counts[g.min] || 0;
      else {
        for (let k in counts) {
          const v = parseInt(k,10);
          if (v >= g.min && v <= g.max) totalCount += counts[k];
        }
      }
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.innerHTML = `<span class="legend-swatch" style="background:${swatchColor}"></span><span>${labelText}${totalCount?(' — '+totalCount+' шт') : ''}</span>`;
      legend.appendChild(item);
    });
    container.appendChild(legend);
  }

  // ---------- packing utilities (minWaste variant) ----------
  function packWithConstraint_min(stock, freq, minWaste) {
    const hasConstraint = (typeof minWaste === 'number' && minWaste > 0);
    const upperCap = hasConstraint ? (stock - minWaste) : stock;
    if (hasConstraint && upperCap < 0) return { chosen: [], sum: 0, impossible: true };

    // build binary-decomposed items
    const items = [];
    for (const k of Object.keys(freq)) {
      const len = parseInt(k,10);
      let cnt = freq[k];
      let power = 1;
      while (cnt > 0) {
        const take = Math.min(power, cnt);
        items.push({ weight: len * take, len: len, take: take });
        cnt -= take;
        power <<= 1;
      }
    }

    const W = stock;
    const dp = new Uint8Array(W + 1);
    const parent = new Int32Array(W + 1).fill(-1);
    const usedItem = new Int32Array(W + 1).fill(-1);
    dp[0] = 1;

    for (let i=0;i<items.length;i++){
      const w = items[i].weight;
      for (let cap = W; cap >= w; cap--) {
        if (!dp[cap] && dp[cap - w]) {
          dp[cap] = 1;
          parent[cap] = cap - w;
          usedItem[cap] = i;
        }
      }
    }

    // when constraint: search cap <= upperCap, take largest such cap
    let best = -1;
    if (hasConstraint) {
      for (let cap = Math.min(upperCap, W); cap >= 0; cap--) {
        if (dp[cap]) { best = cap; break; }
      }
      if (best === -1) return { chosen: [], sum: 0, impossible: true };
    } else {
      for (let cap = W; cap >= 0; cap--) {
        if (dp[cap]) { best = cap; break; }
      }
    }

    if (best <= 0) return { chosen: [], sum: 0, impossible: false };

    // reconstruct
    let cap = best;
    const usedCounts = {};
    while (cap > 0) {
      const idx = usedItem[cap];
      if (idx === -1) break;
      const it = items[idx];
      usedCounts[it.len] = (usedCounts[it.len] || 0) + it.take;
      cap = parent[cap];
    }

    const chosen = [];
    for (const [lenStr, cnt] of Object.entries(usedCounts)) {
      const len = parseInt(lenStr,10);
      for (let i=0;i<cnt;i++) chosen.push(len);
    }
    const sumChosen = chosen.reduce((a,b)=>a+b,0);
    return { chosen, sum: sumChosen, impossible: false };
  }

  // ---------- greedy (strict largest-first if no minWaste) ----------
  function greedyCut(stock, piecesIn, minWaste) {
    if (!minWaste || minWaste <= 0) {
      const arr = [...piecesIn].sort((a,b) => b - a);
      const results = [];
      while (arr.length > 0) {
        const current = { length: stock, pieces: [], remaining: stock };
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] <= current.remaining) {
            current.pieces.push(arr[i]);
            current.remaining -= arr[i];
            arr.splice(i, 1);
            i--;
          }
        }
        results.push(current);
      }
      return results;
    }

    // if minWaste > 0: try packWithConstraint_min first, else fallback to greedy for remaining
    const freq = {};
    piecesIn.forEach(p => freq[p] = (freq[p]||0)+1);
    const results = [];
    let warned = false;

    while (Object.keys(freq).length > 0) {
      const pack = packWithConstraint_min(stock, freq, minWaste);
      if (pack.impossible) {
        if (!warned) {
          showWarning(`Невозможно соблюсти минимальный остаток ${minWaste} мм для текущих кусков — используем жадную упаковку для оставшихся.`);
          warned = true;
        }
        // fallback: pure greedy from remaining
        const arr = [];
        for (const k of Object.keys(freq)) {
          const len = parseInt(k, 10);
          for (let i = 0; i < freq[k]; i++) arr.push(len);
        }
        arr.sort((a,b)=>b-a);
        const current = { length: stock, pieces: [], remaining: stock };
        for (let i=0;i<arr.length;i++){
          if (arr[i] <= current.remaining) {
            current.pieces.push(arr[i]);
            current.remaining -= arr[i];
          }
        }
        current.pieces.forEach(len => {
          freq[len]--;
          if (freq[len] <= 0) delete freq[len];
        });
        results.push(current);
        continue;
      }

      if (pack.chosen.length > 0) {
        results.push({ length: stock, pieces: pack.chosen.slice(), remaining: stock - pack.sum });
        const usedCounts = {};
        pack.chosen.forEach(len => usedCounts[len] = (usedCounts[len]||0)+1);
        for (const [lenStr, cnt] of Object.entries(usedCounts)) {
          const len = parseInt(lenStr,10);
          freq[len] -= cnt;
          if (freq[len] <= 0) delete freq[len];
        }
        continue;
      }

      // last fallback: put largest single piece
      const lens = Object.keys(freq).map(x => parseInt(x,10)).sort((a,b)=>b-a);
      const biggest = lens[0];
      results.push({ length: stock, pieces: [biggest], remaining: stock - biggest });
      freq[biggest]--;
      if (freq[biggest] <= 0) delete freq[biggest];
    }

    return results;
  }

  // ---------- optimal using packWithConstraint_min loop ----------
  function optimalCut(stock, piecesIn, minWaste) {
    const freq = {};
    piecesIn.forEach(p => freq[p] = (freq[p]||0)+1);
    const results = [];
    let warned = false;

    while (Object.keys(freq).length > 0) {
      const pack = packWithConstraint_min(stock, freq, minWaste);
      if (pack.impossible) {
        if (!warned) {
          showWarning(`Невозможно соблюсти минимальный остаток ${minWaste} мм для текущих кусков — будет выполнен расчёт без этого ограничения.`);
          warned = true;
        }
        // fallback: best fill without constraint
        const packNoConstraint = packWithConstraint_min(stock, freq, 0);
        if (packNoConstraint.chosen.length > 0) {
          results.push({ length: stock, pieces: packNoConstraint.chosen.slice(), remaining: stock - packNoConstraint.sum });
          const usedCounts = {};
          packNoConstraint.chosen.forEach(len => usedCounts[len] = (usedCounts[len]||0)+1);
          for (const [lenStr, cnt] of Object.entries(usedCounts)) {
            const len = parseInt(lenStr,10);
            freq[len] -= cnt;
            if (freq[len] <= 0) delete freq[len];
          }
          continue;
        } else {
          const lens = Object.keys(freq).map(x=>parseInt(x,10)).sort((a,b)=>b-a);
          const biggest = lens[0];
          results.push({ length: stock, pieces: [biggest], remaining: stock - biggest });
          freq[biggest]--;
          if (freq[biggest] <= 0) delete freq[biggest];
          continue;
        }
      }

      // accept pack
      results.push({ length: stock, pieces: pack.chosen.slice(), remaining: stock - pack.sum });
      const usedCounts = {};
      pack.chosen.forEach(len => usedCounts[len] = (usedCounts[len]||0)+1);
      for (const [lenStr, cnt] of Object.entries(usedCounts)) {
        const len = parseInt(lenStr,10);
        freq[len] -= cnt;
        if (freq[len] <= 0) delete freq[len];
      }
    }

    return results;
  }

  function showWarning(text) {
    warningBox.textContent = text;
    warningBox.style.display = 'block';
    setTimeout(()=> { warningBox.style.display = 'none'; }, 8000);
  }

  // ---------- display results (DOM build, not innerHTML for pieces) ----------
  function displayResults(results) {
    const container = document.getElementById('results-container');
    container.innerHTML = '';
    let totalWaste = 0;
    const totalStocks = results.length;

    results.forEach((stock, idx) => {
      totalWaste += stock.remaining;

      const resultItem = document.createElement('div');
      resultItem.className = 'result-item';
      if (completedStocks.includes(idx)) resultItem.classList.add('completed');

      // header + checkbox
      const header = document.createElement('h3');
      header.className = 'stock-header';
      header.textContent = `Заготовка #${idx+1}`;
      resultItem.appendChild(header);

      const completedLabel = document.createElement('span');
      completedLabel.className = 'completed-label';
      completedLabel.textContent = 'Выполнено';
      resultItem.appendChild(completedLabel);

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'completed-checkbox';
      checkbox.dataset.index = idx;
      if (completedStocks.includes(idx)) checkbox.checked = true;
      resultItem.appendChild(checkbox);

      // pieces container
      const piecesContainer = document.createElement('div');
      piecesContainer.className = 'cut-pieces';
      // add piece elements with colors based on length
      stock.pieces.forEach(pieceLen => {
    const pieceDiv = document.createElement('div');
    pieceDiv.className = 'cut-piece';
    pieceDiv.textContent = `${pieceLen} мм`;

    const { bg, text } = colorForLength(pieceLen, 350, 2200, 50);
    pieceDiv.style.background = bg;
    pieceDiv.style.color = text;

    piecesContainer.appendChild(pieceDiv);
});
;

      // add waste as last element (red)
      if (stock.remaining > 0) {
        const wasteDiv = document.createElement('div');
        wasteDiv.className = 'cut-piece waste';
        wasteDiv.textContent = `Остаток: ${stock.remaining} мм`;
        piecesContainer.appendChild(wasteDiv);
      }

      resultItem.appendChild(piecesContainer);
      container.appendChild(resultItem);
    });

    // total info
    const info = document.createElement('div');
    info.className = 'total-info';
    const stockLen = parseInt(stockInput.value || 0,10) || 0;
    info.innerHTML = `
      <h3>Итоги раскроя:</h3>
      <p>Всего заготовок: ${totalStocks}</p>
      <p>Общий остаток: ${totalWaste} мм</p>
      <p>Эффективность использования: ${((1 - (totalWaste / (totalStocks * stockLen || 1))) * 100).toFixed(2)}%</p>
    `;
    container.appendChild(info);

    // render legend based on results
    renderLegendForResults('#results-container', results);

    // checkbox handlers
    container.querySelectorAll('.completed-checkbox').forEach(cb=>{
      cb.onchange = function() {
        const idx = parseInt(this.dataset.index,10);
        const parent = this.closest('.result-item');
        if (this.checked) {
          if (!completedStocks.includes(idx)) completedStocks.push(idx);
          parent.classList.add('completed');
          // mark all piece divs inside as done
          parent.querySelectorAll('.cut-piece').forEach(p => p.classList.add('done'));
        } else {
          completedStocks = completedStocks.filter(i => i !== idx);
          parent.classList.remove('completed');
          parent.querySelectorAll('.cut-piece').forEach(p => p.classList.remove('done'));
        }
        updateProgress();
        saveState();
      };
    });

    updateProgress();
  }

  function updateProgress() {
    const total = document.querySelectorAll('.result-item').length;
    const done = completedStocks.length;
    const percent = total > 0 ? (done / total) * 100 : 0;
    document.getElementById('progress-bar').style.width = percent + '%';
    document.getElementById('progress-info').textContent = `Выполнено: ${done} из ${total} заготовок (${percent.toFixed(1)}%)`;
  }

  // ---------- UI buttons ----------
  document.getElementById('add-cut').onclick = () => {
    const len = parseInt(document.getElementById('cut-length').value,10);
    const qty = parseInt(document.getElementById('cut-quantity').value,10) || 1;
    if (!len || len <= 0 || !qty || qty <= 0) { alert('Введите корректную длину и количество'); return; }
    for (let i=0;i<qty;i++) cuts.push(len);
    document.getElementById('cut-length').value = '';
    updateCutsList();
    saveState();
  };

  document.getElementById('calculate').onclick = () => {
    const stockLen = parseInt(stockInput.value,10);
    if (!stockLen || stockLen <= 0) { alert('Введите корректную длину заготовки'); return; }
    if (cuts.length === 0) { alert('Добавьте хотя бы один отрезок'); return; }
    const algo = algoSelect.value;
    const minWasteRaw = minWasteInput.value;
    const minWaste = (minWasteRaw !== '') ? parseInt(minWasteRaw,10) : 0;
    if (minWaste && minWaste >= stockLen) {
      alert('Мин. остаток должен быть меньше длины заготовки');
      return;
    }
    let results = [];
    warningBox.style.display = 'none';
    if (algo === 'greedy') results = greedyCut(stockLen, cuts, minWaste);
    else results = optimalCut(stockLen, cuts, minWaste);
    completedStocks = []; // индексы изменились при новом расчёте
    displayResults(results);
    saveState();
  };

  document.getElementById('mark-all-done').onclick = () => {
    document.querySelectorAll('.completed-checkbox').forEach(cb => { cb.checked = true; cb.dispatchEvent(new Event('change')); });
  };
  document.getElementById('reset-all').onclick = () => {
    document.querySelectorAll('.completed-checkbox').forEach(cb => { cb.checked = false; cb.dispatchEvent(new Event('change')); });
    completedStocks = [];
    updateProgress();
    saveState();
  };

  // init
  updateCutsList();
  // optional: auto-calc on load if desired (commented out)
  // if (cuts.length > 0) document.getElementById('calculate').click();
});
</script>
</body>
</html>
